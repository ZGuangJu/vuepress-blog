最近去梳理了一下这些相关概念、对js执行机制也有了更深的认识、为此翻阅了《javaScript高级教程》、《javaScript权威指南》、《深入理解JavaScript系列》等书籍及相关博客，下面我会结合官方概念保证权威准确性、并结合自己的理解去讲解，如果大家发现哪地方不对，希望能多多指出，我自己也在反复理解这些概念。

我先列出这基本经典书籍中的一些概念描述、让大家都有一个自己的最初认识，也方便后面讲解。然后接着往下看，会结合具体例子讲解概念，会更加清晰，看完之后保证你有一个新的认识。

# 官方概念
## 执行环境(执行上下文Execution Contexts):

>执行环境定义了变量或函数有权访问的其他数据、决定了它们各自的行为。每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入一个环境栈中，而函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境 --《javaScript高级教程》

## 作用域(Scope):

>javaScript中没有块级作用域、取而代之的使用了函数作用域、即变量在声明它们的函数以及这个函数体嵌套的任意函数体内都是有定义的  --《javaScript权威指南》

## 变量对象(Variable Object):

>每一个执行环境都有一个与之关联的变量对象，是一个抽象的概念，环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，单解析器在处理数据时会在后台使用它们。

-------
# 补充个人理解的概念
下面我补充几个自己理解的概念:

## [执行环境栈](https://baike.baidu.com/item/%E6%89%A7%E8%A1%8C%E6%A0%88/22105693?fr=aladdin):

> 存放正在运行子程序(函数即是一个子程序)消息的一个区域，涉及到很多计算机系统知识，如CPU指令，读取内存等，暂时我简单理解为提供存储正在运行的子程序消息的一个区域，不同于对于数据结构中的栈内存。

## 作用域链(Scope Chain):

> 当函数创建时会创建一个包含其父函数变量、父函数的父函数的变量对象、直至全局变量对象的一个作用域链，这个作用域被保存在函数内部的[[scope]]属性中，由于函数本身即是对象，可以理解[[scope]]是后台可以访问的一个属性。当函数调用时，会创建一个自己的活动对象、作为变量对象，被推入到执行环境作用域链的最前端，此时这个[[scope]]属性相当于一个变量对象的集合，并有访问的优先级。作用域链并不保存实际的变量对象，它是一个指针，指向内存中的变量对象列表。

# js事件循环机制

**首先需要了解几个概念:**

当程序启动时, 一个[进程](https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B)被创建，同时也运行一个线程, 即为[主线程](https://baike.baidu.com/item/%E4%B8%BB%E7%BA%BF%E7%A8%8B/9600138?fr=aladdin)，js的运行机制为[单线程](https://baike.baidu.com/item/%E5%8D%95%E7%BA%BF%E7%A8%8B/6972534?fr=aladdin)

先贴一张流程图:

![js事件循环流程图](http://ovqwwz784.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-09-08%20%E4%B8%8B%E5%8D%883.04.05.png)

**流程如下:**

1. 主线程读取js代码, 形成相应的堆和执行栈, 执行同步任务

2. 当主线程遇到异步任务,，指定给异步进程处理, 同时继续执行同步任务
3. 当异步进程处理完毕后， 将相应的异步任务推入到任务队列首部
4. 主线程任务处理完毕后,，查询任务队列，则取出一个任务队列推入到主线程的执行栈
5. 重复执行第2、3、4步，这就称为事件循环

**其中的异步进程有:**
1. 类似onclick等，由浏览器内核的DOM binding模块处理，事件触发时，回调函数添加到任务队列中；
2. setTimeout等，由浏览器内核的Timer模块处理，时间到达时，回调函数添加到任务队列中；
2. Ajax，由浏览器内核的Network模块处理，网络请求返回后，添加到任务队列中。

讲述js事件循环机制主要是想阐述一下执行栈、执行环境(也叫执行上下文)的概念，帮助我们后面更好的理解当调用一个函数时具体发生了什么。

**需要注意的是只有同步任务执行完毕后, 才会去任务队列中去读取任务，而不是异步程序返回结果即执行此异步任务**

# 变量对象(Variable Object, 缩写为VO)

当浏览器第一次加载js脚本程序的时候, 默认进入全局执行环境, 此次的全局环境变量对象为window, 在代码中可以访问。

如果环境是函数, 则将此活动对象做为当前上下文的变量对象(VO = AO), 此时变量对象是不可通过代码来访问的,下面主要对活动对象进行讲解。

# 活动对象(Activation Object ,缩写为AO)

当函数一调用，立刻创建当前上下文的活动对象, 通过arguments属性初始化，值为arguments对象(传入的实参集合,与形参无关,形参做为局部环境的局部变量被定义)

```
AO = {
  arguments: <ArgO>
};
```
arguments对象有以下属性:

- **length:** 真正传递参数的个数;
- **callee:** 指向当前函数的引用,也就是被调用的函数;
- **'类index':** 字符串类型的整数, 值就是arguments对象中对象下标的值,arguments对象应和数组加以区别, 它就是arguments对象,只是能和数组具有相同的length属性,和可以通过下标来访问值


```
function show (a, b, c) {
    // 通过Object.prototype.toString.call()精准判断类型, 证明arguments不同于数组类型
    var arr = [1, 2, 3];
    console.log(Object.prototype.toString.call(arr)); // [object Array]

    console.log(Object.prototype.toString.call(arguments)); // [object Arguments]

    console.log(arguments.length) // 2  传递进来实参的个数

    console.log(arguments.callee === show) // true 就是被调用的函数show自身

    //参数共享

    console.log(a === arguments[0]) // true

    a = 15;

    console.log(arguments[0]) // 15

    arguments[0] = 25;

    console.log(a)  // 25;

    但是，对于没有传进来的参数c, 和arguments的第三个索引是不共享的

    c = 25;

    console.log(arguments[2]) // undefined

    argument[2] = 35;

    console.log(c) // 25

}

show(10, 20);
```

接着往下走,这才是关键的地方,执行环境的代码被分成两个阶段来处理：

1. 进入执行环境
2. 执行函数的代码

## 进入执行环境

前面说过,函数如果被调用, 进入执行环境(上下文)，并立即创建活动对象, 通过arguments属性初始化, 与此同时会扫描执行环境中的所有形参、所有函数声明、所有变量声明, 添加到活动对象(AO)中, 并确定this的值，然后会开始执行代码。

**在进入执行环境这个阶段:**

**所有形参声明:**

>形参名称作为活动对象属性被创建, 如果传递实参, 值就为实参值, 如果没有传递参数, 值就为undefined

**所有函数声明:**

>函数名称作为活动对象的属性被创建，值是一个指针在内存中, 指向这个函数,如果变量对象已经存在相同名称的属性, 则完全替换。

**所有变量声明:**

>所有变量名称作为活动对象的属性被创建, 值为undefined,但是和函数声明不同的是, 如果变量名称跟已经存在的属性(形式参数和函数)相同、则不会覆盖


```
function foo(a, b) {
    var c = 10;
    function d() {
        console.log('d');
    }
    var e = function () {
        console.log('e');
    };
    (function f() {})
    if (true) {
        var g = 20;
    } else {
        var h = 30;
    }
}

foo(10);
```

此时在进入foo函数执行上下文时,AO为:

```
AO(foo) = {
    arguments: {
        0: 10,
        length: 1
    },
    a: 10,
    b: undefined,
    c: fundefined,
    d: '指向d函数的指针',
    e: undefined,
    g: undefined,
    h: undefined  // 虽然else中的代码永远不会执行,但是h仍然是活动对象中的属性
}

```

**这个例子做如下几点说明:**

1. 关于函数,只会创建函数声明作为活动对象的属性, 而f函数作为函数表达式并不会出现在活动对象(AO)中

2. e虽然值是一个函数, 但是作为变量属性被活动对象创建

## 代码执行阶段

在进入执行上下文阶段，活动对象拥有了属性，但是很多属性值为undefined, 到代码直接阶段就开始为这些属性赋值了

**还是上面的代码例子, 此时活动对象如下:**

AO(foo) = {
    arguments: {
        0: 10,
        length: 1
    },
    a: 10,
    b: undefined,
    c: 10, // 赋值为undefined
    d: '指向d函数的指针',
    e: '指向e函数的指针' // 作为变量被保存在内存中
    g: 20,
    h: undefined  // 声明h变量,但是没有赋值
}

```
变量对象包括:{arguments对象+函数形参+内部变量＋函数声明(但不包含表达式)}
```

这时这个活动对象, 即作为当前执行环境的变量对象会被推到此执行环境作用域链的最前端, 另外别忘记了当前上线问指针,假定执行环境为一个对象,则整个执行环境可以访问到的属性如下:

```
fooExecutionContext = {
    scopeChain(作用域链):  AO(foo的活动对象)+所有父执行环境的活动对象,
    AO(foo的变量对象): {
        arguments: {
            0: 10,
            length: 1
        },
        a: 10,
        b: undefined,
        c: 10, // 赋值为undefined
        d: '指向d函数的指针',
        e: '指向e函数的指针',
        g: 20,
        h: undefined
    },
    this: 当前执行环境的上下文指针
}
```

下面的例子为了说明一下变量声明的顺序及变量同名不会影响函数声明

```
console.log(foo); //  foo的函数体
var foo = 10;
console.log(foo) // 10
function foo() {};
foo = 20;
console.log(foo); // 20

```

在代码执行之前, 就会读取函数声明,变量声明的顺序在函数声明和形参声明之后, 整个流程如下:

进入执行环境阶段:

```
1. var VO = {}
2. VO[foo] = 'foo函数指针'
3. 扫描到var foo = 10，但是foo做为function已经声明，所以变量声明不会影响同名的函数声明，如果代码中没有foo函数声明的话,则foo为undefined
```

代码执行阶段:

```
1. VO[foo] = 10;
2. VO[foo] = 20;
```

解析代码完成。

# 总结个人理解的概念

写了这么多,终于写完了,最后,想说一下我对这几个概念的理解:

## 执行环境(执行上下文):

>作为一段可执行的程序,我抽象把它理解成一个任务,当函数被调用,立刻创建当前执行环境,并被推入到执行栈中

## 作用域:

> 一个抽象的概念, 对当前执行环境所有数据的访问权限

## 变量对象:

> 一个抽象的概念，与执行环境相对象，全局执行环境的变量对象为window,可访问。在函数环境中，函数调用后创建的活动对象即作为当前执行环境的变量对象, 此时从引用的角度看，二者是一个东东。

## 活动对象:

> 作为具体概念存在，在全局执行环境不存在这个概念，全局变量对象的变量对象指向window，而且并不存在arguments属性

整篇文章基本上这就是我能理解到的程度了， 很多概念查找很多书籍并加入自己的理解，在后续理解逐渐加深后,也会更新本文， 希望能帮到对此也迷惑的人，如果有理解不对的地方，希望大家多多给出指导意见,谢谢。